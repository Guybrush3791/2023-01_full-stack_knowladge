"use strict";
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/immutability-helper/index.js
var require_immutability_helper = __commonJS({
  "node_modules/immutability-helper/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function stringifiable(obj) {
      return typeof obj === "object" && !("toString" in obj) ? Object.prototype.toString.call(obj).slice(8, -1) : obj;
    }
    var isProduction = typeof process === "object" && false;
    function invariant(condition, message) {
      if (!condition) {
        if (isProduction) {
          throw new Error("Invariant failed");
        }
        throw new Error(message());
      }
    }
    exports.invariant = invariant;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var splice = Array.prototype.splice;
    var toString = Object.prototype.toString;
    function type(obj) {
      return toString.call(obj).slice(8, -1);
    }
    var assign = Object.assign || function(target, source) {
      getAllKeys(source).forEach(function(key) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      });
      return target;
    };
    var getAllKeys = typeof Object.getOwnPropertySymbols === "function" ? function(obj) {
      return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
    } : function(obj) {
      return Object.keys(obj);
    };
    function copy(object) {
      return Array.isArray(object) ? assign(object.constructor(object.length), object) : type(object) === "Map" ? new Map(object) : type(object) === "Set" ? new Set(object) : object && typeof object === "object" ? assign(Object.create(Object.getPrototypeOf(object)), object) : object;
    }
    var Context = function() {
      function Context2() {
        this.commands = assign({}, defaultCommands);
        this.update = this.update.bind(this);
        this.update.extend = this.extend = this.extend.bind(this);
        this.update.isEquals = function(x, y) {
          return x === y;
        };
        this.update.newContext = function() {
          return new Context2().update;
        };
      }
      Object.defineProperty(Context2.prototype, "isEquals", {
        get: function() {
          return this.update.isEquals;
        },
        set: function(value) {
          this.update.isEquals = value;
        },
        enumerable: true,
        configurable: true
      });
      Context2.prototype.extend = function(directive, fn) {
        this.commands[directive] = fn;
      };
      Context2.prototype.update = function(object, $spec) {
        var _this = this;
        var spec = typeof $spec === "function" ? { $apply: $spec } : $spec;
        if (!(Array.isArray(object) && Array.isArray(spec))) {
          invariant(!Array.isArray(spec), function() {
            return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
          });
        }
        invariant(typeof spec === "object" && spec !== null, function() {
          return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(_this.commands).join(", ") + ".");
        });
        var nextObject = object;
        getAllKeys(spec).forEach(function(key) {
          if (hasOwnProperty.call(_this.commands, key)) {
            var objectWasNextObject = object === nextObject;
            nextObject = _this.commands[key](spec[key], nextObject, spec, object);
            if (objectWasNextObject && _this.isEquals(nextObject, object)) {
              nextObject = object;
            }
          } else {
            var nextValueForKey = type(object) === "Map" ? _this.update(object.get(key), spec[key]) : _this.update(object[key], spec[key]);
            var nextObjectValue = type(nextObject) === "Map" ? nextObject.get(key) : nextObject[key];
            if (!_this.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === "undefined" && !hasOwnProperty.call(object, key)) {
              if (nextObject === object) {
                nextObject = copy(object);
              }
              if (type(nextObject) === "Map") {
                nextObject.set(key, nextValueForKey);
              } else {
                nextObject[key] = nextValueForKey;
              }
            }
          }
        });
        return nextObject;
      };
      return Context2;
    }();
    exports.Context = Context;
    var defaultCommands = {
      $push: function(value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, "$push");
        return value.length ? nextObject.concat(value) : nextObject;
      },
      $unshift: function(value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, "$unshift");
        return value.length ? value.concat(nextObject) : nextObject;
      },
      $splice: function(value, nextObject, spec, originalObject) {
        invariantSplices(nextObject, spec);
        value.forEach(function(args) {
          invariantSplice(args);
          if (nextObject === originalObject && args.length) {
            nextObject = copy(originalObject);
          }
          splice.apply(nextObject, args);
        });
        return nextObject;
      },
      $set: function(value, _nextObject, spec) {
        invariantSet(spec);
        return value;
      },
      $toggle: function(targets, nextObject) {
        invariantSpecArray(targets, "$toggle");
        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;
        targets.forEach(function(target) {
          nextObjectCopy[target] = !nextObject[target];
        });
        return nextObjectCopy;
      },
      $unset: function(value, nextObject, _spec, originalObject) {
        invariantSpecArray(value, "$unset");
        value.forEach(function(key) {
          if (Object.hasOwnProperty.call(nextObject, key)) {
            if (nextObject === originalObject) {
              nextObject = copy(originalObject);
            }
            delete nextObject[key];
          }
        });
        return nextObject;
      },
      $add: function(values, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, "$add");
        invariantSpecArray(values, "$add");
        if (type(nextObject) === "Map") {
          values.forEach(function(_a) {
            var key = _a[0], value = _a[1];
            if (nextObject === originalObject && nextObject.get(key) !== value) {
              nextObject = copy(originalObject);
            }
            nextObject.set(key, value);
          });
        } else {
          values.forEach(function(value) {
            if (nextObject === originalObject && !nextObject.has(value)) {
              nextObject = copy(originalObject);
            }
            nextObject.add(value);
          });
        }
        return nextObject;
      },
      $remove: function(value, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, "$remove");
        invariantSpecArray(value, "$remove");
        value.forEach(function(key) {
          if (nextObject === originalObject && nextObject.has(key)) {
            nextObject = copy(originalObject);
          }
          nextObject.delete(key);
        });
        return nextObject;
      },
      $merge: function(value, nextObject, _spec, originalObject) {
        invariantMerge(nextObject, value);
        getAllKeys(value).forEach(function(key) {
          if (value[key] !== nextObject[key]) {
            if (nextObject === originalObject) {
              nextObject = copy(originalObject);
            }
            nextObject[key] = value[key];
          }
        });
        return nextObject;
      },
      $apply: function(value, original) {
        invariantApply(value);
        return value(original);
      }
    };
    var defaultContext = new Context();
    exports.isEquals = defaultContext.update.isEquals;
    exports.extend = defaultContext.extend;
    exports.default = defaultContext.update;
    exports.default.default = module2.exports = assign(exports.default, exports);
    function invariantPushAndUnshift(value, spec, command) {
      invariant(Array.isArray(value), function() {
        return "update(): expected target of " + stringifiable(command) + " to be an array; got " + stringifiable(value) + ".";
      });
      invariantSpecArray(spec[command], command);
    }
    function invariantSpecArray(spec, command) {
      invariant(Array.isArray(spec), function() {
        return "update(): expected spec of " + stringifiable(command) + " to be an array; got " + stringifiable(spec) + ". Did you forget to wrap your parameter in an array?";
      });
    }
    function invariantSplices(value, spec) {
      invariant(Array.isArray(value), function() {
        return "Expected $splice target to be an array; got " + stringifiable(value);
      });
      invariantSplice(spec.$splice);
    }
    function invariantSplice(value) {
      invariant(Array.isArray(value), function() {
        return "update(): expected spec of $splice to be an array of arrays; got " + stringifiable(value) + ". Did you forget to wrap your parameters in an array?";
      });
    }
    function invariantApply(fn) {
      invariant(typeof fn === "function", function() {
        return "update(): expected spec of $apply to be a function; got " + stringifiable(fn) + ".";
      });
    }
    function invariantSet(spec) {
      invariant(Object.keys(spec).length === 1, function() {
        return "Cannot have more than one key in an object with $set";
      });
    }
    function invariantMerge(target, specValue) {
      invariant(specValue && typeof specValue === "object", function() {
        return "update(): $merge expects a spec of type 'object'; got " + stringifiable(specValue);
      });
      invariant(target && typeof target === "object", function() {
        return "update(): $merge expects a target of type 'object'; got " + stringifiable(target);
      });
    }
    function invariantMapOrSet(target, command) {
      var typeOfTarget = type(target);
      invariant(typeOfTarget === "Map" || typeOfTarget === "Set", function() {
        return "update(): " + stringifiable(command) + " expects a target of type Set or Map; got " + stringifiable(typeOfTarget);
      });
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CodePreviewPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/store/obsidian.ts
var import_obsidian2 = require("obsidian");

// src/utils/vault.ts
var cachedRead = (file) => __async(void 0, null, function* () {
  const store3 = useObsidianStore();
  const { app } = store3;
  const { vault, metadataCache } = app;
  const contents = yield vault.cachedRead(file);
  return {
    path: file.path,
    contents,
    stat: file.stat,
    metadata: metadataCache.getFileCache(file)
  };
});

// src/utils/path.ts
var _path = __toESM(require("path"));

// src/utils/file.ts
var fs = __toESM(require("fs"));

// src/utils/lodash.ts
function isString(o) {
  return Object.prototype.toString.call(o) === "[object String]";
}
function isNumber(o) {
  return Object.prototype.toString.call(o) === "[object Number]";
}
function isRegExp(o) {
  return Object.prototype.toString.call(o) === "[object RegExp]" || /^\/(.*)\/$/.test(o);
}

// src/utils/file.ts
function readFile(path) {
  const { app } = useObsidianStore();
  return app.vault.adapter.read(relative(path));
}
var selectFileSync = (path, start = 1, end) => __async(void 0, null, function* () {
  const content = yield readFile(path);
  const lines = content.split("\n");
  const ret = lines;
  let startIndex = isNumber(start) ? start - 1 : 0;
  let endIndex = isNumber(end) ? end - 1 : lines.length - 1;
  if (isString(start)) {
    startIndex = lines.findIndex((line) => line.indexOf(start) > -1);
  }
  if (isRegExp(start)) {
    const reg = new RegExp(start.replace(/^\/(.*)\/$/, "$1"));
    startIndex = lines.findIndex((line) => reg.test(line));
  }
  if (isString(end)) {
    if (end.startsWith("+")) {
      endIndex = startIndex + Number(end.replace("+", ""));
    } else {
      endIndex = lines.findIndex((line) => line.indexOf(end) > -1);
    }
  }
  if (isRegExp(end)) {
    const reg = new RegExp(end.replace(/^\/(.*)\/$/, "$1"));
    endIndex = lines.findIndex((line) => reg.test(line));
  }
  return ret.slice(startIndex, endIndex + 1).join("\n");
});
var write = (path, contents, options) => __async(void 0, null, function* () {
  const { app } = useObsidianStore();
  return yield app.vault.adapter.write(path, contents, options);
});
var stat = (path) => fs.statSync(path);
var clearRelative = (p) => p.replace("../", "").replace("..\\", "").replace("./", "").replace(".\\", "");
var match = (pattern, source) => {
  if (/^\/(.*)\/$/.test(pattern)) {
    const reg = new RegExp(pattern.replace(/^\/(.*)\/$/, "$1"));
    return reg.test(source);
  }
  return source.indexOf(pattern) > -1;
};
function list(options) {
  return __async(this, null, function* () {
    let {
      paths
    } = options;
    const {
      recurs = true,
      alias,
      filesPath = [],
      replacer
    } = options;
    if (typeof alias === "string") {
      return filesPath;
    }
    if (paths.length === 0) {
      return filesPath;
    }
    const { app } = useObsidianStore();
    const { adapter } = app.vault;
    const [first] = paths;
    if (!first.startsWith("./") && !first.startsWith("../")) {
      paths = paths.map((p) => relative(p));
    }
    for (let i = 0; i < paths.length; i++) {
      const path = paths[i];
      const { files, folders } = yield adapter.list(path);
      const { folders: filterFolders, files: filterFiles } = filterPathByAlias(alias, folders, files);
      filterFiles.forEach((p) => filesPath.push(replacer ? replacer(clearRelative(p)) : clearRelative(p)));
      if (filterFolders.length > 0 && recurs) {
        yield list(__spreadProps(__spreadValues({}, options), {
          paths: filterFolders,
          filesPath
        }));
      }
    }
    return filesPath;
  });
}
function filterPathByAlias(aliasObj, folders, files) {
  if (typeof aliasObj === "string") {
    return {
      folders: [],
      files: []
    };
  }
  const {
    include = [],
    exclude = [],
    includeFile = [],
    excludeFile = []
  } = aliasObj;
  const includeFolders = include.length === 0 ? folders : folders.filter((source) => include.some((pattern) => match(pattern, source)));
  const excludeFolders = exclude.length === 0 ? includeFolders : includeFolders.filter((source) => !exclude.some((pattern) => match(pattern, source)));
  const includeFiles = includeFile.length === 0 ? files : files.filter((source) => includeFile.some((pattern) => match(pattern, source)));
  const excludeFiles = excludeFile.length === 0 ? includeFiles : includeFiles.filter((source) => !excludeFile.some((pattern) => match(pattern, source)));
  return {
    folders: excludeFolders,
    files: excludeFiles
  };
}
function watchFile2(filename, listener) {
  return fs.watchFile(filename, listener);
}
function unwatchFile2(filename, listener) {
  return fs.unwatchFile(filename, listener);
}
function watch2(filename, listener, options = {
  recursive: true
}) {
  const abortSignal = new AbortController();
  options.signal = abortSignal.signal;
  fs.watch(filename, options, listener);
  return abortSignal;
}

// src/store/default_setting.ts
var import_obsidian = require("obsidian");

// src/default_settings.ts
var APP_NAME = "Code Preview";
var DEFAULT_SETTINGS = {
  watchAlias: false,
  watchCode: false,
  highLightColor: "#2d82cc20",
  include: [],
  exclude: ["node_modules", ".obsidian"],
  includeFile: ["/\\.(j|t)s$/", "/\\.css$/"],
  excludeFile: [],
  linenumber: true,
  alias: {
    "code": {
      alias: "/../src",
      includeFile: ["/\\.(j|t)s$/"]
    },
    "test": {
      alias: "/../tests",
      includeFile: ["/\\.(j|t)s$/"]
    }
  }
};

// src/store/default_setting.ts
var SettingStore = class {
  constructor() {
    this.aliasFilePathMap = /* @__PURE__ */ new Map();
    this.includeFilePath = /* @__PURE__ */ new Set();
    this.settings = null;
  }
  init() {
    return __async(this, null, function* () {
      yield this.initIncludeFilePath();
      yield this.initAliasFilePath();
    });
  }
  reset(settings) {
    this.settings = settings;
  }
  initAliasFilePath() {
    return __async(this, null, function* () {
      this.aliasFilePathMap.clear();
      const { alias } = this.settings;
      for (const key in alias) {
        const aliasObj = this.getAlias(alias[key]);
        const path = yield this.initAliasFilePathByObj(key, aliasObj);
        if (path) {
          const pathSet = this.aliasFilePathMap.get(key);
          const listener = (eventType, filename) => {
            const { files, folders } = filterPathByAlias(aliasObj, [filename], [filename]);
            if (folders.length > 0 && files.length > 0) {
              pathSet == null ? void 0 : pathSet.add(filename.replace(/\\+/g, "/"));
            }
          };
          this.settings.watchAlias && watch2(path, listener);
        }
      }
    });
  }
  initAliasFilePathByObj(key, aliasObj) {
    return __async(this, null, function* () {
      if (typeof aliasObj === "string") {
        return;
      }
      try {
        const path = resolve(aliasObj.alias);
        this.aliasFilePathMap.set(key, new Set(yield list({
          paths: [path],
          recurs: true,
          alias: aliasObj,
          replacer(path2) {
            return path2.replace(`${key}/`, "");
          }
        })));
        return path;
      } catch (error) {
        console.error(error);
        if (error instanceof Error) {
          new import_obsidian.Notice(`[${APP_NAME} Alias]: ${aliasObj.alias} not find`);
        } else if (typeof error === "string") {
          new import_obsidian.Notice(`[${APP_NAME} Alias]: ${aliasObj.alias} not find`);
        }
      }
    });
  }
  initIncludeFilePath() {
    return __async(this, null, function* () {
      try {
        this.includeFilePath = new Set(yield list({
          paths: ["/"],
          recurs: true,
          alias: this.settings
        }));
      } catch (error) {
        console.error(error);
      }
    });
  }
  getAlias(alias) {
    const { include, exclude, includeFile, excludeFile } = this.settings;
    if (typeof alias === "string") {
      return {
        alias,
        include,
        exclude,
        includeFile,
        excludeFile
      };
    }
    return {
      alias: alias.alias,
      include: alias.include ? alias.include : include,
      exclude: alias.exclude ? alias.exclude : exclude,
      includeFile: alias.includeFile ? alias.includeFile : includeFile,
      excludeFile: alias.excludeFile ? alias.excludeFile : excludeFile
    };
  }
};
var store = null;
var useSettingStore = () => {
  if (store) {
    return store;
  }
  store = new SettingStore();
  return store;
};

// src/utils/path.ts
var resolve = (path, sourcePath) => {
  if (path == null) {
    return "";
  }
  const store3 = useObsidianStore();
  const { vaultBasePath } = store3;
  if (path.startsWith("/")) {
    return path.startsWith(vaultBasePath) ? path : vaultBasePath + path;
  }
  const settingStore = useSettingStore();
  const { alias } = settingStore.settings;
  const aliasKeys = Object.keys(alias);
  let isAlias = false;
  for (let i = 0; i < aliasKeys.length; i++) {
    const key = aliasKeys[i];
    if (path.startsWith(key)) {
      isAlias = true;
      path = path.replace(key, settingStore.getAlias(alias[key]).alias);
      return resolve(path, sourcePath);
    }
  }
  path = path.replace("${vaultBasePath}", vaultBasePath);
  if (isAlias) {
    return _path.normalize(path);
  }
  if (sourcePath != null) {
    return `${vaultBasePath}/${_path.dirname(sourcePath)}/${path}`;
  }
  return path.startsWith(vaultBasePath) ? path : `${vaultBasePath}/${path}`;
};
function relative(path, sourcePath) {
  const store3 = useObsidianStore();
  const { vaultBasePath } = store3;
  return _path.relative(vaultBasePath, resolve(path, sourcePath));
}
var extname2 = (path) => _path.extname(path).slice(1);
var resolveObsidianPath = (path, sourcePath) => {
  if (path == null) {
    return "";
  }
  const store3 = useObsidianStore();
  const { vaultBasePath } = store3;
  const fullPath = resolve(path, sourcePath).replace(vaultBasePath, "").replace(/\\/g, "/").replace(/\/\//g, "/");
  return fullPath.startsWith("/") ? fullPath.slice(1) : fullPath;
};

// src/utils/env.ts
var IS_DEV = process.argv[2] !== "production";

// src/utils/log.ts
var methods = ["log", "table", "info", "error"];
var _console = {};
methods.forEach((method) => {
  _console[method] = (...args) => {
    if (!IS_DEV) {
      return;
    }
    console[method](...args);
  };
});
var log_default = _console;

// src/utils/metadataCache.ts
function getPathByMarkdownLink(link) {
  if (/\[\[.*\]\]/.test(link)) {
    link = link.replace(/\[\[(.*)\]\]/, "$1");
  }
  if (link.startsWith("/")) {
    link = link.slice(1);
  }
  return link;
}

// src/store/obsidian.ts
var searchPreviewAnnotation = (0, import_obsidian2.prepareFuzzySearch)("%%preview %%");
var ObsidianStore = class {
  constructor(plugin) {
    this.app = null;
    this.plugin = null;
    this.vaultBasePath = null;
    this.pageMap = /* @__PURE__ */ new Map();
    this.resolveCount = 0;
    this.init(plugin);
  }
  init(plugin) {
    if (plugin === this.plugin) {
      return;
    }
    this.plugin = plugin;
    this.app = plugin.app;
    this.vaultBasePath = plugin.app.vault.adapter.basePath;
    plugin.registerEvent(this.app.metadataCache.on("resolve", (file) => this.onMetadataCacheResolve(file)));
    plugin.registerEvent(this.app.vault.on("delete", (file) => this.onVaultDelete(file)));
    plugin.registerEvent(this.app.vault.on("rename", (file, oldPath) => this.onVaultRename(file, oldPath)));
    console.log(`Obsidian ${APP_NAME}`);
  }
  onVaultDelete(file) {
    if (!this.pageMap.has(file.path)) {
      return;
    }
    this.pageMap.delete(file.path);
    this.resolveCount--;
  }
  onVaultRename(file, oldPath) {
    if (!this.pageMap.has(file.path)) {
      return;
    }
    this.pageMap.delete(oldPath);
    this.onMetadataCacheResolve(file);
  }
  onMetadataCacheResolve(file) {
    return __async(this, null, function* () {
      const page = yield cachedRead(file);
      let configList = [];
      try {
        configList = parsePreviewYaml(page.contents, page.path);
      } catch (error) {
        this.addCache(page);
        return;
      }
      configList.length > 0 && (yield this.generatePreviewLinks(page, configList));
      this.addCache(page);
    });
  }
  addCache(page) {
    if (this.pageMap.has(page.path)) {
      return;
    }
    this.pageMap.set(page.path, page);
    this.resolveCount++;
  }
  searchPreviewAnnotations(contents) {
    const result = searchPreviewAnnotation(contents);
    let links = [];
    if (result == null) {
      return { links };
    }
    const { matches } = result;
    const [[annotationStart, linksStart], [linksEnd, annotationEnd]] = matches;
    if (linksStart == null || linksEnd == null) {
      return { links, annotationStart, annotationEnd };
    }
    const mdLinks = contents.slice(linksStart, linksEnd).match(/\[\[([^\[\]]*)\]\]/g);
    links = mdLinks == null ? void 0 : mdLinks.map((md) => md.replace(/\[\[([^\[\]]*)\]\]/, "$1"));
    return {
      annotationStart,
      annotationEnd,
      linksStart,
      linksEnd,
      links
    };
  }
  generatePreviewLinks(page, configList) {
    return __async(this, null, function* () {
      const { contents } = page;
      let { links, annotationStart, annotationEnd } = this.searchPreviewAnnotations(contents);
      if (!configList || configList.length === 0) {
        if (this.pageMap.has(page.path) && annotationStart != null) {
          yield write(page.path, `${contents.slice(0, annotationStart)}${contents.slice(annotationEnd)}`);
          this.pageMap.delete(page.path);
        }
        return;
      }
      const linkConfigList = configList.filter((config) => Reflect.has(config, "link"));
      if (linkConfigList.length === 0) {
        return;
      }
      const codeBlockLinks = linkConfigList.map((config) => resolveObsidianPath(config.link, page.path));
      const codeBlockLinksSet = /* @__PURE__ */ new Set([...codeBlockLinks]);
      const concatSet = /* @__PURE__ */ new Set([...links, ...codeBlockLinksSet]);
      if (links.length === concatSet.size && links.length === codeBlockLinksSet.size) {
        return;
      }
      const linkAnnotation = wrapLinkAnnotation([...codeBlockLinksSet].map(getPathByMarkdownLink).map((link) => `[[${link}]]`).join(""));
      const addLinksContents = annotationStart == null ? `${contents}
${linkAnnotation}` : `${contents.slice(0, annotationStart)}${linkAnnotation}${contents.slice(annotationEnd)}`;
      yield write(page.path, addLinksContents);
    });
  }
};
var store2 = null;
var useObsidianStore = (plugin) => {
  if (store2) {
    return store2;
  }
  if (!plugin) {
    log_default.error("Init Failed");
    return store2;
  }
  store2 = new ObsidianStore(plugin);
  return store2;
};

// src/utils/string.ts
var import_obsidian4 = require("obsidian");
var codeBlock = "```";
var wrapCodeBlock = (language, source) => `${codeBlock} ${language}
${source}
${codeBlock}`;
var wrapLinkAnnotation = (links) => `%%preview${links}%%`;
function trimPreviewWrap(contents) {
  if (!isString(contents)) {
    return "";
  }
  return contents.replace(/(```preview)|(```)/g, "");
}
function parsePreviewYaml(contents, pagePath) {
  const { settings } = useSettingStore();
  const previewBlockList = contents.match(/```preview(.|\s)*?```/g);
  if (!previewBlockList || previewBlockList.length === 0) {
    return [];
  }
  const configList = previewBlockList.map((source) => (0, import_obsidian4.parseYaml)(trimPreviewWrap(source))).filter((config) => {
    try {
      const fileStat = stat(resolve(config.path || config.link, pagePath));
      return true;
    } catch (error) {
      return false;
    }
  });
  return configList;
}

// src/setting.class.ts
var import_obsidian7 = require("obsidian");

// src/setting/Setting.ts
var import_obsidian6 = require("obsidian");

// src/setting/SettingsManager.ts
var import_immutability_helper = __toESM(require_immutability_helper());
var import_obsidian5 = require("obsidian");
var SettingsManager = class {
  constructor(plugin, config, settings) {
    this.applyDebounceTimer = 0;
    this.app = plugin.app;
    this.plugin = plugin;
    this.config = config;
    this.settings = settings;
  }
  applySettingsUpdate(spec) {
    clearTimeout(this.applyDebounceTimer);
    this.applyDebounceTimer = window.setTimeout(() => {
      this.settings = (0, import_immutability_helper.default)(this.settings, spec);
      this.config.onSettingsChange(this.settings);
    }, 200);
  }
  getSetting(key) {
    return this.settings[key];
  }
  getDefaultSetting(key) {
    return DEFAULT_SETTINGS[key];
  }
  constructUI(containerEl) {
    const { settings } = this.plugin;
    containerEl.empty();
    containerEl.createEl("h3", {
      text: "Code Preview"
    });
    new import_obsidian5.Setting(containerEl).setName("Watch alias folder change").addToggle((toggle) => toggle.setValue(this.plugin.settings.watchAlias).onChange((value) => {
      this.plugin.settings.watchAlias = value;
      this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Watch preview file change").addToggle((toggle) => toggle.setValue(this.plugin.settings.watchCode).onChange((value) => {
      this.plugin.settings.watchCode = value;
      this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Linenumber").addToggle((toggle) => toggle.setValue(this.plugin.settings.linenumber).onChange((value) => {
      this.plugin.settings.linenumber = value;
      this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("highLightColor").addText((text) => {
      text.setPlaceholder(DEFAULT_SETTINGS.highLightColor).setValue(settings.highLightColor || "").onChange((value) => __async(this, null, function* () {
        try {
          settings.highLightColor = value;
          yield this.plugin.saveSettings();
        } catch (e) {
          return false;
        }
      }));
    });
    new import_obsidian5.Setting(containerEl).setName("Path alias").setDesc("map path").addTextArea((text) => {
      text.setPlaceholder(JSON.stringify(DEFAULT_SETTINGS.alias, null, 2)).setValue(JSON.stringify(settings.alias, null, 2) || "").onChange((value) => __async(this, null, function* () {
        try {
          const newValue = JSON.parse(value);
          settings.alias = newValue;
          yield this.plugin.saveSettings();
        } catch (e) {
          return false;
        }
      }));
      text.inputEl.rows = 10;
      text.inputEl.cols = 60;
    });
    new import_obsidian5.Setting(containerEl).setName("include").addTextArea((text) => {
      text.setPlaceholder(JSON.stringify(DEFAULT_SETTINGS.include)).setValue(JSON.stringify(settings.include) || "").onChange((value) => __async(this, null, function* () {
        try {
          const newValue = JSON.parse(value);
          settings.include = newValue;
          yield this.plugin.saveSettings();
        } catch (e) {
          return false;
        }
      }));
      text.inputEl.rows = 1;
      text.inputEl.cols = 60;
    });
    new import_obsidian5.Setting(containerEl).setName("exclude").addTextArea((text) => {
      text.setPlaceholder(JSON.stringify(DEFAULT_SETTINGS.exclude)).setValue(JSON.stringify(settings.exclude) || "").onChange((value) => __async(this, null, function* () {
        try {
          const newValue = JSON.parse(value);
          settings.exclude = newValue;
          yield this.plugin.saveSettings();
        } catch (e) {
          return false;
        }
      }));
      text.inputEl.rows = 1;
      text.inputEl.cols = 60;
    });
    new import_obsidian5.Setting(containerEl).setName("includeFile").addTextArea((text) => {
      text.setPlaceholder(JSON.stringify(DEFAULT_SETTINGS.includeFile)).setValue(JSON.stringify(settings.includeFile) || "").onChange((value) => __async(this, null, function* () {
        try {
          const newValue = JSON.parse(value);
          settings.includeFile = newValue;
          yield this.plugin.saveSettings();
        } catch (e) {
          return false;
        }
      }));
      text.inputEl.rows = 1;
      text.inputEl.cols = 60;
    });
    new import_obsidian5.Setting(containerEl).setName("excludeFile").addTextArea((text) => {
      text.setPlaceholder(JSON.stringify(DEFAULT_SETTINGS.excludeFile)).setValue(JSON.stringify(settings.excludeFile) || "").onChange((value) => __async(this, null, function* () {
        try {
          const newValue = JSON.parse(value);
          settings.excludeFile = newValue;
          yield this.plugin.saveSettings();
        } catch (e) {
          return false;
        }
      }));
      text.inputEl.rows = 1;
      text.inputEl.cols = 60;
    });
  }
};

// src/setting/Setting.ts
var SettingsTab = class extends import_obsidian6.PluginSettingTab {
  constructor(plugin, config) {
    super(plugin.app, plugin);
    this.plugin = plugin;
    this.settingsManager = new SettingsManager(plugin, config, plugin.settings);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.settingsManager.constructUI(containerEl);
  }
};

// src/setting.class.ts
var SettingPlugin = class extends import_obsidian7.Plugin {
  get settings() {
    return this.settingsStore.settings;
  }
  set settings(newSetting) {
    this.settingsStore.reset(newSetting);
  }
  onload() {
    return __async(this, null, function* () {
      this.settingsStore = useSettingStore();
      this.store = useObsidianStore(this);
      yield this.loadSettings();
      this.settingsStore.init();
      this.settingsTab = new SettingsTab(this, {
        onSettingsChange: (newSettings) => __async(this, null, function* () {
          this.settings = newSettings;
          yield this.saveSettings();
        })
      });
      this.addSettingTab(this.settingsTab);
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};

// src/suggest.class.ts
var import_obsidian8 = require("obsidian");
function sort(results) {
  results.sort(function(e, t) {
    return t.match.score - e.match.score;
  });
}
var Suggest = class extends import_obsidian8.EditorSuggest {
  onTrigger(cursor, editor, file) {
    const lineText = editor.getLine(cursor.line);
    const pathMatches = lineText.match(/^(>|\s)*path:\s*(.*)/);
    if (pathMatches) {
      return this.onPathTrigger(cursor, pathMatches);
    }
    return null;
  }
  onPathTrigger(cursor, matches) {
    const [origin, , query = ""] = matches;
    return {
      start: {
        line: cursor.line,
        ch: origin.length - query.length
      },
      end: {
        line: cursor.line,
        ch: origin.length
      },
      query,
      type: "path" /* path */
    };
  }
  getSuggestions(context) {
    let result = [];
    const aliasKeys = this.getAliasSuggestions(context);
    if (aliasKeys.length > 0) {
      result = result.concat(aliasKeys);
    }
    const aliasPath = this.getAliasPathSuggestions(context);
    if (aliasPath.length > 0) {
      result = result.concat(aliasPath);
    }
    sort(result);
    return result;
  }
  isSuggestEqQuery(suggests, query) {
    if (suggests.length !== 1) {
      return false;
    }
    const [{ item }] = suggests;
    return item === query;
  }
  getAliasSuggestions(context) {
    const { settings: { alias }, includeFilePath } = useSettingStore();
    const aliasKeys = Object.keys(alias);
    const result = [];
    const fuzzySearch = (0, import_obsidian8.prepareFuzzySearch)(context.query);
    for (const item of aliasKeys) {
      const match2 = fuzzySearch(item);
      match2 && result.push({
        match: match2,
        item
      });
    }
    if (includeFilePath.size > 0) {
      includeFilePath.forEach((item) => {
        const match2 = fuzzySearch(item);
        match2 && result.push({
          match: match2,
          item
        });
      });
    }
    if (this.isSuggestEqQuery(result, context.query)) {
      return [];
    }
    return result;
  }
  getAliasPathSuggestions(context) {
    const { settings: { alias }, aliasFilePathMap } = useSettingStore();
    const aliasKeys = Object.keys(alias);
    const aliasKey = aliasKeys.find((key) => {
      const startsWithReg = new RegExp(`^(${key}|${key}\\/|${key}\\\\)`);
      return startsWithReg.test(context.query);
    });
    if (!aliasKey) {
      return [];
    }
    const files = aliasFilePathMap.get(aliasKey);
    const paths = new Set(files);
    if (paths.size === 0) {
      return [];
    }
    const result = [];
    const query = context.query.replace(aliasKey, "").replace(/^\\/, "").replace(/^\//, "");
    const fuzzySearch = (0, import_obsidian8.prepareFuzzySearch)(query);
    for (let item of paths) {
      item = this.clearAliasPath(alias[aliasKey], item);
      const match2 = fuzzySearch(item);
      match2 && result.push({
        match: match2,
        item
      });
    }
    if (this.isSuggestEqQuery(result, query)) {
      return [];
    }
    this.context.aliasKey = aliasKey;
    return result;
  }
  clearAliasPath(alias, path) {
    if (typeof alias !== "string") {
      alias = alias.alias;
    }
    const aliasPath = alias.replace(/^\//, "").replace(/^\\/, "").replace(/^\.\.\//, "").replace(/^\.\.\\/, "");
    return path.replace(`${aliasPath}/`, "");
  }
  renderSuggestion(value, el) {
    el.setText(value.item);
  }
  selectSuggestion(value, evt) {
    if (evt instanceof KeyboardEvent && evt.key.toUpperCase() !== "ENTER") {
      return;
    }
    const { editor, start, end, aliasKey: prefix, query } = this.context;
    const replacement = !prefix ? value.item : `${prefix}/${value.item}`;
    editor.replaceRange(replacement, start, end);
    editor.setCursor(end.line, end.ch + replacement.length - query.length);
    this.close();
  }
  close() {
    super.close();
  }
};

// src/main.ts
var CodePreviewPlugin = class extends SettingPlugin {
  constructor() {
    super(...arguments);
    this.style = {
      top: "8px",
      lineHeight: "21px",
      fontSize: "14px"
    };
    this.watchFileMap = /* @__PURE__ */ new WeakMap();
  }
  onload() {
    return __async(this, null, function* () {
      __superGet(CodePreviewPlugin.prototype, this, "onload").call(this);
      this.app.workspace.onLayoutReady(() => this.initCss());
      this.registerEvent(this.app.workspace.on("resize", () => this.initCss()));
      this.registerPriorityCodeblockPostProcessor("preview", -100, (source, el, ctx) => __async(this, null, function* () {
        return this.preview(source, el, ctx, ctx.sourcePath);
      }));
      this.suggest = new Suggest(this.app);
      this.registerEditorSuggest(this.suggest);
    });
  }
  onunload() {
    super.onunload();
  }
  initCss() {
    const out = createDiv({
      cls: "markdown-rendered markdown-source-view",
      attr: {
        style: "position: absolute; top: 0; left: -999999px;"
      }
    });
    const pre = createEl("pre", {
      "cls": "language-code-preview-plugin-tmp"
    });
    const code = createEl("code", {
      "cls": "language-css is-loaded"
    });
    out.appendChild(pre);
    pre.appendChild(code);
    document.body.appendChild(out);
    const preStyles = getComputedStyle(pre);
    const codeStyles = getComputedStyle(code);
    this.style = {
      top: preStyles.paddingTop,
      lineHeight: codeStyles.lineHeight,
      fontSize: codeStyles.fontSize
    };
    out.remove();
  }
  registerPriorityCodeblockPostProcessor(language, priority, processor) {
    const registered = this.registerMarkdownCodeBlockProcessor(language, processor);
    registered.sortOrder = priority;
  }
  code(source, sourcePath) {
    return __async(this, null, function* () {
      const result = {
        start: 1,
        code: "",
        language: "",
        highlight: "",
        lines: [],
        filePath: "",
        linenumber: this.settings.linenumber
      };
      try {
        source = source.replace(/^([^:]+):(.+)\n/, "$1: $2\n");
        const codeSetting = (0, import_obsidian9.parseYaml)(source);
        if (codeSetting === source) {
          result.code = `YAML: parse error.`;
          return result;
        }
        const path = (codeSetting == null ? void 0 : codeSetting.path) || (codeSetting == null ? void 0 : codeSetting.link);
        const filePath = resolve(path, sourcePath);
        result.linenumber = codeSetting.linenumber == null ? result.linenumber : codeSetting.linenumber;
        result.language = (codeSetting == null ? void 0 : codeSetting.language) || (codeSetting == null ? void 0 : codeSetting.lang) || extname2(path);
        result.code = yield selectFileSync(filePath, codeSetting.start, codeSetting.end);
        if (!result.code) {
          if (codeSetting.start || codeSetting.end) {
            result.code = `File: ${filePath} not match start or end`;
          } else {
            result.code = `File: ${filePath} not created or empty.`;
          }
          return result;
        }
        result.start = codeSetting.start;
        result.filePath = filePath;
        result.highlight = String(codeSetting.highlight);
        result.lines = result.code.split("\n");
      } catch (error) {
        if (error instanceof Error) {
          result.code = error.message;
        } else if (typeof error === "string") {
          result.code = error;
        } else {
          result.code = error;
        }
      }
      return result;
    });
  }
  addLineNumber(pre, div, lineSize, start = 1) {
    div.classList.add("code-block-wrap");
    const codeEl = pre.querySelector("code");
    if (!codeEl) {
      return;
    }
    const { top, lineHeight, fontSize } = this.style;
    const line_number = createEl("span", {
      cls: "code-block-line_num-wrap",
      attr: {
        style: `top: ${top}; line-height: ${lineHeight}; font-size: ${fontSize}; counter-set: line-num ${start - 1};`
      }
    });
    Array.from({ length: lineSize }, (v, k) => k).forEach((i) => {
      const singleLine = createEl("span", "code-block-line_num");
      line_number.appendChild(singleLine);
    });
    pre.appendChild(line_number);
    pre.classList.add("code-block-pre__has-line_num");
  }
  addLineHighLight(pre, highLightLines, lineSize) {
    const codeEl = pre.querySelector("code");
    if (!codeEl) {
      return;
    }
    const { top, lineHeight, fontSize } = this.style;
    const highLightWrap = createEl("div", {
      attr: {
        style: `top: ${top}; line-height: ${lineHeight}; font-size: ${fontSize};`
      }
    });
    highLightWrap.className = "code-block-highlight-wrap";
    for (let i = 0; i < lineSize; i++) {
      const singleLine = createEl("span", "code-block-highlight");
      if (highLightLines.get(i + 1)) {
        singleLine.style.backgroundColor = this.settings.highLightColor || "#2d82cc20";
      }
      highLightWrap.appendChild(singleLine);
    }
    pre.appendChild(highLightWrap);
  }
  analyzeHighLightLines(lines, source) {
    const result = /* @__PURE__ */ new Map();
    const strs = typeof source !== "string" ? source : source.replace(/\s*/g, "").split(",");
    strs.forEach((it) => {
      if (/\d+-\d+/.test(it)) {
        const left = Number(it.split("-")[0]);
        const right = Number(it.split("-")[1]);
        for (let i = left; i <= right; i++) {
          result.set(i, true);
        }
      } else if (/^\/(.*)\/$/.test(it)) {
        const reg = new RegExp(it.replace(/^\/(.*)\/$/, "$1"));
        lines.forEach((line, i) => {
          if (reg.test(line)) {
            result.set(i + 1, true);
          }
        });
      } else if (/[^0-9]/.test(it)) {
        lines.forEach((line, i) => {
          if (line.indexOf(it) > -1) {
            result.set(i + 1, true);
          }
        });
      } else {
        result.set(Number(it), true);
      }
    });
    return result;
  }
  preview(source, el, component, sourcePath) {
    return __async(this, null, function* () {
      const { containerEl } = component;
      this.removeWatchByEl(containerEl, el, sourcePath);
      const render = () => __async(this, null, function* () {
        el.empty();
        const { code, language, lines, highlight, filePath, linenumber, start } = yield this.code(source, sourcePath);
        yield import_obsidian9.MarkdownRenderer.renderMarkdown(wrapCodeBlock(language, code), el, sourcePath, component);
        const pre = el.querySelector("pre");
        if (!pre) {
          return filePath;
        }
        linenumber && this.addLineNumber(pre, el, lines.length, start);
        highlight && this.addLineHighLight(pre, this.analyzeHighLightLines(lines, highlight), lines.length);
        return filePath;
      });
      const filename = yield render();
      this.settings.watchCode && this.addWatch(containerEl, el, sourcePath, filename, render);
    });
  }
  addWatch(containerEl, el, sourcePath, filename, handler) {
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    const renderLeaf = leaves.find((leaf) => leaf.view.containerEl.querySelector(".view-content") === containerEl);
    if (!renderLeaf) {
      return;
    }
    const listener = () => {
      if (!this.settings.watchCode) {
        this.removeWatch(renderLeaf, el, sourcePath);
        return;
      }
      handler();
    };
    watchFile2(filename, listener);
    let map = this.watchFileMap.get(renderLeaf);
    if (!map) {
      this.watchFileMap.set(renderLeaf, map = {});
    }
    let elMap = map[sourcePath];
    if (!elMap) {
      map[sourcePath] = elMap = /* @__PURE__ */ new Map();
    }
    let unwatch = elMap.get(el);
    if (!unwatch) {
      elMap.set(el, unwatch = []);
    }
    unwatch.push(() => unwatchFile2(filename, listener));
    this.registerEvent(this.app.workspace.on("layout-change", () => {
      const leaves2 = this.app.workspace.getLeavesOfType("markdown");
      const hasLeaf = leaves2.some((l) => l === renderLeaf);
      if (!this.settings.watchCode || !hasLeaf || renderLeaf.view.file.path !== sourcePath) {
        return this.removeWatch(renderLeaf, el, sourcePath);
      }
    }));
  }
  removeWatchByEl(containerEl, el, sourcePath) {
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    const renderLeaf = leaves.find((leaf) => leaf.view.containerEl.querySelector(".view-content") === containerEl);
    if (!renderLeaf) {
      return;
    }
    this.removeWatch(renderLeaf, el, sourcePath);
  }
  removeWatch(leaf, el, sourcePath, clearOther = true) {
    const map = this.watchFileMap.get(leaf);
    if (!map) {
      return;
    }
    const elMap = map[sourcePath];
    if (!elMap) {
      return;
    }
    const blocks = Array.from(leaf.view.containerEl.querySelectorAll(".block-language-preview"));
    const clear = (el2) => {
      let unwatch = elMap.get(el2);
      if (!unwatch) {
        elMap.set(el2, unwatch = []);
      }
      elMap.delete(el2);
      unwatch.forEach((fn) => fn());
    };
    blocks.forEach((block) => {
      if (block !== el) {
        return;
      }
      clear(el);
    });
    if (clearOther) {
      const watchEls = [];
      for (const k of elMap.keys()) {
        watchEls.push(k);
      }
      watchEls.forEach((el2) => {
        if (blocks.includes(el2)) {
          return;
        }
        clear(el2);
      });
    }
  }
};
